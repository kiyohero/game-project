<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>ã‚¤ãƒ³ãƒ™ãƒ¼ãƒ€ãƒ¼ã‚²ãƒ¼ãƒ </title>
  <link rel="stylesheet" href="common.css">
  <script src="common.js" defer></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; background: #f5f0fa; min-height: 100vh; display: flex; flex-direction: column; align-items: center; padding: 20px; user-select: none; -webkit-user-select: none; }
    h1 { font-size: 2rem; color: #6b5b7a; margin-bottom: 10px; }
    @keyframes title-glow { 0%, 100% { text-shadow: none; } 50% { text-shadow: 0 0 10px #9b8ab8; } }
    .header { display: flex; align-items: center; gap: 15px; margin-bottom: 15px; width: 100%; max-width: 340px; justify-content: space-between; }
    .score-container { background: #9b8ab8; padding: 10px 20px; border-radius: 6px; text-align: center; position: relative; overflow: hidden; }
    .score-container::after { content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent); animation: shine 3s infinite; }
    @keyframes shine { to { left: 100%; } }
    .score-label { font-size: 0.7rem; color: #e8e0f0; text-transform: uppercase; font-weight: bold; }
    .score-value { font-size: 1.5rem; color: #fff; font-weight: bold; transition: transform 0.1s; }
    .score-value.pop { animation: score-pop 0.2s ease; }
    @keyframes score-pop { 0% { transform: scale(1); } 50% { transform: scale(1.3); color: #fff; } 100% { transform: scale(1); } }
    .btn { background: #7a6b8a; color: white; border: none; padding: 12px 20px; border-radius: 6px; font-size: 1rem; font-weight: bold; cursor: pointer; transition: transform 0.1s, box-shadow 0.2s; }
    .btn:hover { box-shadow: 0 0 15px rgba(122, 107, 138, 0.5); }
    .btn:active { transform: scale(0.95); }
    .game-container { position: relative; background: #2d2640; border: 3px solid #9b8ab8; border-radius: 8px; box-shadow: 0 0 20px rgba(155, 138, 184, 0.3); overflow: hidden; }
    .game-container.shake { animation: shake 0.3s ease; }
    @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
    .game-container.damage { animation: damage-flash 0.1s ease 3; }
    @keyframes damage-flash { 0%, 100% { border-color: #9b8ab8; } 50% { border-color: #ff6b6b; box-shadow: 0 0 30px rgba(255, 107, 107, 0.5); } }
    canvas { display: block; }
    .controls { display: flex; gap: 15px; margin-top: 15px; }
    .control-btn { width: 70px; height: 70px; background: #e8e0f0; border: 2px solid #9b8ab8; border-radius: 50%; color: #6b5b7a; font-size: 1.5rem; display: flex; align-items: center; justify-content: center; cursor: pointer; -webkit-tap-highlight-color: transparent; transition: all 0.1s; }
    .control-btn:active { background: #9b8ab8; color: white; box-shadow: 0 0 20px rgba(155,138,184,0.5); }
    .fire-btn { width: 90px; height: 90px; background: #7a6b8a; border-color: #7a6b8a; color: white; font-size: 1rem; font-weight: bold; }
    .fire-btn:active { background: #9b8ab8; box-shadow: 0 0 25px rgba(155,138,184,0.5); }
    .overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(255,255,255,0.9); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; opacity: 0; pointer-events: none; transition: opacity 0.3s; }
    .overlay.show { opacity: 1; pointer-events: auto; }
    .overlay h2 { font-size: 2rem; color: #6b5b7a; margin-bottom: 20px; }
    .overlay.game-over h2 { color: #e74c3c; }
    .overlay .final-score { font-size: 1.2rem; color: #6b5b7a; margin-bottom: 20px; }
    .how-to-play { background: #e8e0f0; border-radius: 8px; margin-bottom: 15px; max-width: 340px; }
    .how-to-play summary { color: #6b5b7a; font-size: 1rem; font-weight: bold; padding: 12px 15px; cursor: pointer; list-style: none; display: flex; justify-content: space-between; align-items: center; }
    .how-to-play summary::-webkit-details-marker { display: none; }
    .how-to-play summary::after { content: '+'; font-size: 1.3rem; }
    .how-to-play[open] summary::after { content: '-'; }
    .how-to-play ul { color: #6b5b7a; font-size: 0.85rem; line-height: 1.8; padding: 0 15px 15px 35px; }
    .how-to-play li { margin-bottom: 5px; }
    .instructions { color: #6b5b7a; margin-top: 10px; font-size: 0.85rem; }
    .lives { display: flex; gap: 5px; }
    .life { width: 20px; height: 20px; background: #9b8ab8; clip-path: polygon(50% 0%, 0% 100%, 100% 100%); transition: all 0.3s; }
    .life.lost { animation: life-lost 0.5s ease forwards; }
    @keyframes life-lost { to { transform: scale(0) rotate(180deg); opacity: 0; } }
    .score-popup { position: absolute; color: #ffd93d; font-weight: bold; font-size: 14px; pointer-events: none; animation: popup 0.8s ease forwards; text-shadow: 0 0 5px #ffd93d; }
    @keyframes popup { 0% { opacity: 1; transform: translateY(0) scale(1); } 100% { opacity: 0; transform: translateY(-30px) scale(1.5); } }
  </style>
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
  <!-- ãƒ©ãƒ³ã‚­ãƒ³ã‚°æ©Ÿèƒ½ -->
  <link rel="stylesheet" href="ranking.css">
  <script src="firebase-config.js"></script>
  <script src="ranking.js" defer></script>
</head>
<body>
  <h1>ã‚¤ãƒ³ãƒ™ãƒ¼ãƒ€ãƒ¼ã‚²ãƒ¼ãƒ </h1>
  <div class="header">
    <div class="score-container">
      <div class="score-label">ã‚¹ã‚³ã‚¢</div>
      <div class="score-value" id="score">0</div>
    </div>
    <div class="lives" id="lives"></div>
    <button class="btn ranking-btn" id="rankingBtn">ğŸ†</button>
    <button class="btn" id="restart">ãƒªãƒˆãƒ©ã‚¤</button>
  </div>
  <div class="game-container" id="gameContainer">
    <canvas id="game" width="320" height="400"></canvas>
  </div>
  <div class="controls">
    <button class="control-btn" id="leftBtn">â†</button>
    <button class="control-btn fire-btn" id="fireBtn">ã¯ã£ã—ã‚ƒ</button>
    <button class="control-btn" id="rightBtn">â†’</button>
  </div>
  <p class="instructions">ãƒœã‚¿ãƒ³ã¾ãŸã¯çŸ¢å°ã‚­ãƒ¼ï¼‹ã‚¹ãƒšãƒ¼ã‚¹ã§æ“ä½œ</p>
  <details class="how-to-play">
    <summary>ã‚ãã³ã‹ãŸ</summary>
    <ul>
      <li>ã—ãŸã®ãƒœã‚¿ãƒ³ã€ã¾ãŸã¯ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã®â†â†’ã§ã†ã”ãã‚ˆ</li>
      <li>ã€Œã¯ã£ã—ã‚ƒã€ãƒœã‚¿ãƒ³ã€ã¾ãŸã¯ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§ãƒ“ãƒ¼ãƒ ã‚’ã†ã¤ã‚ˆ</li>
      <li>ã¦ããŒãŠã‚Šã¦ãã‚‹ã¾ãˆã«ã€ãœã‚“ã¶ãŸãŠãã†ï¼</li>
      <li>ã¦ãã®ã“ã†ã’ãã«ã‚ãŸã‚‹ã¨ã€ãƒ©ã‚¤ãƒ•ãŒã¸ã‚‹ã‚ˆ</li>
      <li>ãƒ©ã‚¤ãƒ•ãŒ0ã«ãªã£ãŸã‚‰ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼</li>
    </ul>
  </details>
  <div class="overlay" id="overlay">
    <h2 id="message">ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</h2>
    <p class="final-score">ã‚¹ã‚³ã‚¢: <span id="finalScore">0</span></p>
    <button class="btn" id="retryBtn">ã‚‚ã†ä¸€åº¦</button>
  </div>
  <div class="overlay show" id="startOverlay">
    <h2>ğŸš€ ã‚¤ãƒ³ãƒ™ãƒ¼ãƒ€ãƒ¼ã‚²ãƒ¼ãƒ </h2>
    <p style="color: #6b5b7a; margin-bottom: 20px;">ã¦ãã‚’ãœã‚“ã¶ãŸãŠãã†ï¼</p>
    <button class="btn" id="startBtn" style="font-size: 1.3rem; padding: 15px 40px;">ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const overlay = document.getElementById('overlay');
    const messageEl = document.getElementById('message');
    const finalScoreEl = document.getElementById('finalScore');
    const gameContainer = document.getElementById('gameContainer');

    const W = canvas.width, H = canvas.height;
    const startOverlay = document.getElementById('startOverlay');
    let player, enemies, bullets, enemyBullets, particles, stars, score, lives, gameOver, gameStarted, direction, moveTimer, shootTimer, playerFlash;

    // ===== ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªé–¢é€£ =====
    let audioCtx = null;
    let bgmOscillator = null;
    let bgmGain = null;

    function initAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
    }

    // ç™ºå°„éŸ³ï¼ˆé«˜éŸ³ã®ãƒ”ãƒ¥ãƒ¼ï¼‰
    function playShootSound() {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.type = 'square';
      osc.frequency.setValueAtTime(880, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(1760, audioCtx.currentTime + 0.05);
      gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.1);
    }

    // çˆ†ç™ºéŸ³ï¼ˆãƒã‚¤ã‚ºç³»ï¼‰
    function playExplosionSound() {
      if (!audioCtx) return;
      const bufferSize = audioCtx.sampleRate * 0.15;
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
      }
      const noise = audioCtx.createBufferSource();
      const gain = audioCtx.createGain();
      noise.buffer = buffer;
      noise.connect(gain);
      gain.connect(audioCtx.destination);
      gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
      noise.start();
    }

    // ãƒ€ãƒ¡ãƒ¼ã‚¸éŸ³ï¼ˆä½éŸ³ã®ãƒ–ã‚¶ãƒ¼ï¼‰
    function playDamageSound() {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(150, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.2);
      gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.3);
    }

    // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼éŸ³ï¼ˆä¸‹é™éŸ³éšï¼‰
    function playGameOverSound() {
      if (!audioCtx) return;
      const notes = [440, 392, 349, 294];
      notes.forEach((freq, i) => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.type = 'square';
        osc.frequency.value = freq;
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime + i * 0.15);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + i * 0.15 + 0.14);
        osc.start(audioCtx.currentTime + i * 0.15);
        osc.stop(audioCtx.currentTime + i * 0.15 + 0.15);
      });
    }

    // ã‚¯ãƒªã‚¢éŸ³ï¼ˆä¸Šæ˜‡éŸ³éšï¼‰
    function playClearSound() {
      if (!audioCtx) return;
      const notes = [523, 659, 784, 1047];
      notes.forEach((freq, i) => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.type = 'square';
        osc.frequency.value = freq;
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime + i * 0.12);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + i * 0.12 + 0.11);
        osc.start(audioCtx.currentTime + i * 0.12);
        osc.stop(audioCtx.currentTime + i * 0.12 + 0.12);
      });
    }

    // BGMï¼ˆãƒ¬ãƒˆãƒ­é¢¨ãƒ«ãƒ¼ãƒ—ï¼‰
    function startBGM() {
      if (!audioCtx || bgmOscillator) return;
      bgmGain = audioCtx.createGain();
      bgmGain.connect(audioCtx.destination);
      bgmGain.gain.value = 0.03; // æ§ãˆã‚ãªéŸ³é‡

      const playNote = (freq, startTime, duration) => {
        const osc = audioCtx.createOscillator();
        const noteGain = audioCtx.createGain();
        osc.connect(noteGain);
        noteGain.connect(bgmGain);
        osc.type = 'square';
        osc.frequency.value = freq;
        noteGain.gain.setValueAtTime(0.5, startTime);
        noteGain.gain.exponentialRampToValueAtTime(0.1, startTime + duration * 0.8);
        osc.start(startTime);
        osc.stop(startTime + duration);
        return osc;
      };

      // ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ï¼ˆãƒ«ãƒ¼ãƒ—ç”¨ã®ãƒ¡ãƒ­ãƒ‡ã‚£ãƒ¼ï¼‰
      const melody = [131, 165, 196, 165, 147, 165, 196, 220]; // ãƒ¬ãƒˆãƒ­ãªãƒ™ãƒ¼ã‚¹éŸ³
      const noteDuration = 0.25;
      const loopDuration = melody.length * noteDuration;

      let currentLoop = 0;
      const scheduleLoop = () => {
        if (!bgmGain) return;
        const startTime = audioCtx.currentTime + currentLoop * loopDuration;
        melody.forEach((freq, i) => {
          playNote(freq, startTime + i * noteDuration, noteDuration * 0.9);
        });
        currentLoop++;
        if (bgmGain) {
          setTimeout(scheduleLoop, loopDuration * 900); // å°‘ã—æ—©ã‚ã«ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
        }
      };

      bgmOscillator = true; // ãƒ•ãƒ©ã‚°ã¨ã—ã¦ä½¿ç”¨
      scheduleLoop();
    }

    function stopBGM() {
      if (bgmGain) {
        bgmGain.disconnect();
        bgmGain = null;
      }
      bgmOscillator = null;
    }

    // æ˜Ÿã®èƒŒæ™¯ã‚’ä½œæˆ
    function createStars() {
      stars = [];
      for (let i = 0; i < 50; i++) {
        stars.push({
          x: Math.random() * W,
          y: Math.random() * H,
          size: Math.random() * 2 + 0.5,
          speed: Math.random() * 0.5 + 0.2,
          brightness: Math.random()
        });
      }
    }

    function init() {
      player = { x: W / 2 - 15, y: H - 40, w: 30, h: 20, speed: 5 };
      enemies = [];
      bullets = [];
      enemyBullets = [];
      particles = [];
      score = 0;
      lives = 3;
      gameOver = false;
      gameStarted = false;
      direction = 1;
      moveTimer = 0;
      shootTimer = 0;
      playerFlash = 0;

      createStars();

      for (let row = 0; row < 5; row++) {
        for (let col = 0; col < 8; col++) {
          enemies.push({
            x: 20 + col * 36,
            y: 40 + row * 30,
            w: 28,
            h: 20,
            alive: true,
            type: row < 2 ? 2 : row < 4 ? 1 : 0,
            frame: 0
          });
        }
      }

      scoreEl.textContent = '0';
      updateLives();
      overlay.classList.remove('show');
      overlay.classList.remove('game-over');
      gameContainer.classList.remove('shake', 'damage');
    }

    function updateLives() {
      livesEl.innerHTML = '';
      for (let i = 0; i < 3; i++) {
        const life = document.createElement('div');
        life.className = 'life' + (i >= lives ? ' lost' : '');
        livesEl.appendChild(life);
      }
    }

    function createExplosion(x, y, color) {
      for (let i = 0; i < 12; i++) {
        const angle = (Math.PI * 2 / 12) * i;
        const speed = Math.random() * 3 + 2;
        particles.push({
          x: x,
          y: y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 1,
          color: color,
          size: Math.random() * 4 + 2
        });
      }
    }

    function showScorePopup(x, y, points) {
      const popup = document.createElement('div');
      popup.className = 'score-popup';
      popup.textContent = '+' + points;
      popup.style.left = (canvas.offsetLeft + x) + 'px';
      popup.style.top = (canvas.offsetTop + y) + 'px';
      gameContainer.appendChild(popup);
      setTimeout(() => popup.remove(), 800);
    }

    function drawStars() {
      stars.forEach(star => {
        const brightness = 0.3 + star.brightness * 0.7 * (0.5 + 0.5 * Math.sin(Date.now() * 0.003 + star.x));
        ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function updateStars() {
      stars.forEach(star => {
        star.y += star.speed;
        if (star.y > H) {
          star.y = 0;
          star.x = Math.random() * W;
        }
      });
    }

    function drawPlayer() {
      if (playerFlash > 0) {
        playerFlash--;
        if (Math.floor(playerFlash / 3) % 2 === 0) return;
      }

      // ã‚°ãƒ­ãƒ¼åŠ¹æœ
      ctx.shadowColor = '#00ff88';
      ctx.shadowBlur = 15;
      ctx.fillStyle = '#00ff88';
      ctx.beginPath();
      ctx.moveTo(player.x + player.w / 2, player.y);
      ctx.lineTo(player.x, player.y + player.h);
      ctx.lineTo(player.x + player.w, player.y + player.h);
      ctx.closePath();
      ctx.fill();

      // ã‚¨ãƒ³ã‚¸ãƒ³ã®ç‚
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#ff6b6b';
      const flameHeight = 5 + Math.random() * 5;
      ctx.beginPath();
      ctx.moveTo(player.x + player.w / 2 - 5, player.y + player.h);
      ctx.lineTo(player.x + player.w / 2, player.y + player.h + flameHeight);
      ctx.lineTo(player.x + player.w / 2 + 5, player.y + player.h);
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    function drawEnemy(e) {
      const colors = ['#ff6b6b', '#ffd93d', '#ff8c42'];
      ctx.fillStyle = colors[e.type];

      // æ•µã®å½¢ï¼ˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä»˜ãï¼‰
      const wobble = Math.sin(Date.now() * 0.005 + e.x * 0.1) * 2;
      ctx.fillRect(e.x + 4, e.y + wobble, e.w - 8, 6);
      ctx.fillRect(e.x, e.y + 6 + wobble, e.w, 8);
      ctx.fillRect(e.x + 2, e.y + 14 + wobble, 6, 6);
      ctx.fillRect(e.x + e.w - 8, e.y + 14 + wobble, 6, 6);

      // ç›®
      ctx.fillStyle = '#fff';
      ctx.fillRect(e.x + 6, e.y + 8 + wobble, 4, 4);
      ctx.fillRect(e.x + e.w - 10, e.y + 8 + wobble, 4, 4);
    }

    function drawBullet(b, isPlayer) {
      if (isPlayer) {
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¼¾ï¼ˆã‚°ãƒ­ãƒ¼ä»˜ãï¼‰
        ctx.shadowColor = '#00ff88';
        ctx.shadowBlur = 10;
        ctx.fillStyle = '#00ff88';
        ctx.fillRect(b.x, b.y, b.w, b.h);
        // ãƒˆãƒ¬ã‚¤ãƒ«
        ctx.fillStyle = 'rgba(0, 255, 136, 0.3)';
        ctx.fillRect(b.x, b.y + b.h, b.w, 15);
      } else {
        // æ•µã®å¼¾
        ctx.shadowColor = '#ff6b6b';
        ctx.shadowBlur = 8;
        ctx.fillStyle = '#ff6b6b';
        ctx.fillRect(b.x, b.y, b.w, b.h);
      }
      ctx.shadowBlur = 0;
    }

    function drawParticles() {
      particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalAlpha = 1;
    }

    function updateParticles() {
      particles = particles.filter(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.03;
        p.vy += 0.1; // é‡åŠ›
        return p.life > 0;
      });
    }

    function update() {
      if (gameOver || !gameStarted) return;

      updateStars();
      updateParticles();

      // ã¦ãã®ã„ã©ã†
      moveTimer++;
      if (moveTimer > 30) {
        moveTimer = 0;
        let hitEdge = false;
        enemies.forEach(e => {
          if (e.alive) {
            e.x += direction * 10;
            if (e.x <= 0 || e.x + e.w >= W) hitEdge = true;
          }
        });
        if (hitEdge) {
          direction *= -1;
          enemies.forEach(e => {
            if (e.alive) e.y += 15;
          });
        }
      }

      // ã¦ãã®ã“ã†ã’ã
      shootTimer++;
      if (shootTimer > 50) {
        shootTimer = 0;
        const aliveEnemies = enemies.filter(e => e.alive);
        if (aliveEnemies.length > 0) {
          const shooter = aliveEnemies[Math.floor(Math.random() * aliveEnemies.length)];
          enemyBullets.push({ x: shooter.x + shooter.w / 2 - 2, y: shooter.y + shooter.h, w: 4, h: 10, speed: 4 });
        }
      }

      bullets.forEach(b => b.y -= b.speed);
      enemyBullets.forEach(b => b.y += b.speed);

      bullets = bullets.filter(b => b.y > -b.h);
      enemyBullets = enemyBullets.filter(b => b.y < H);

      // ã‚ãŸã‚Šã¯ã‚“ã¦ã„ï¼ˆã˜ã¶ã‚“ã®ãŸã¾â†’ã¦ãï¼‰
      bullets.forEach(b => {
        enemies.forEach(e => {
          if (e.alive && b.x < e.x + e.w && b.x + b.w > e.x && b.y < e.y + e.h && b.y + b.h > e.y) {
            e.alive = false;
            b.y = -100;
            const points = (e.type + 1) * 10;
            score += points;
            scoreEl.textContent = score;
            scoreEl.classList.add('pop');
            setTimeout(() => scoreEl.classList.remove('pop'), 200);

            // çˆ†ç™ºã¨ã‚¹ã‚³ã‚¢ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—
            const colors = ['#ff6b6b', '#ffd93d', '#ff8c42'];
            createExplosion(e.x + e.w / 2, e.y + e.h / 2, colors[e.type]);
            showScorePopup(e.x + e.w / 2, e.y, points);
            playExplosionSound();
          }
        });
      });

      // ã‚ãŸã‚Šã¯ã‚“ã¦ã„ï¼ˆã¦ãã®ãŸã¾â†’ã˜ã¶ã‚“ï¼‰
      enemyBullets.forEach(b => {
        if (b.x < player.x + player.w && b.x + b.w > player.x && b.y < player.y + player.h && b.y + b.h > player.y) {
          b.y = H + 100;
          lives--;
          playerFlash = 30;
          playDamageSound();
          gameContainer.classList.add('damage');
          setTimeout(() => gameContainer.classList.remove('damage'), 300);
          updateLives();
          if (lives <= 0) {
            gameOver = true;
            stopBGM();
            playGameOverSound();
            createExplosion(player.x + player.w / 2, player.y + player.h / 2, '#00ff88');
            showOverlay('ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼', true);
          }
        }
      });

      enemies.forEach(e => {
        if (e.alive && e.y + e.h >= player.y) {
          gameOver = true;
          stopBGM();
          playGameOverSound();
          showOverlay('ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼', true);
        }
      });

      if (enemies.every(e => !e.alive)) {
        gameOver = true;
        stopBGM();
        playClearSound();
        showOverlay('ã‚¯ãƒªã‚¢ï¼', false);
      }
    }

    function draw() {
      ctx.fillStyle = '#0f0f23';
      ctx.fillRect(0, 0, W, H);

      drawStars();
      drawParticles();
      drawPlayer();
      enemies.forEach(e => { if (e.alive) drawEnemy(e); });
      bullets.forEach(b => drawBullet(b, true));
      enemyBullets.forEach(b => drawBullet(b, false));
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    function showOverlay(msg, isGameOver) {
      messageEl.textContent = msg;
      finalScoreEl.textContent = score;
      if (isGameOver) {
        overlay.classList.add('game-over');
      }

      // ã‚¹ã‚³ã‚¢ãŒ1ä»¥ä¸Šãªã‚‰ãƒ©ãƒ³ã‚­ãƒ³ã‚°ç™»éŒ²ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’è¡¨ç¤º
      if (score > 0) {
        Ranking.showSubmitModal('invader', score, () => {
          overlay.classList.add('show');
        });
      } else {
        overlay.classList.add('show');
      }
    }

    function shoot() {
      if (gameOver || !gameStarted) return;
      if (bullets.length < 3) {
        bullets.push({ x: player.x + player.w / 2 - 2, y: player.y, w: 4, h: 10, speed: 7 });
        playShootSound();
      }
    }

    const keys = {};
    document.addEventListener('keydown', e => {
      keys[e.key] = true;
      if (e.key === ' ') { e.preventDefault(); shoot(); }
    });
    document.addEventListener('keyup', e => keys[e.key] = false);

    setInterval(() => {
      if (gameOver || !gameStarted) return;
      if (keys['ArrowLeft'] && player.x > 0) player.x -= player.speed;
      if (keys['ArrowRight'] && player.x < W - player.w) player.x += player.speed;
    }, 16);

    let leftPressed = false, rightPressed = false;

    document.getElementById('leftBtn').addEventListener('touchstart', e => { e.preventDefault(); leftPressed = true; });
    document.getElementById('leftBtn').addEventListener('touchend', () => leftPressed = false);
    document.getElementById('rightBtn').addEventListener('touchstart', e => { e.preventDefault(); rightPressed = true; });
    document.getElementById('rightBtn').addEventListener('touchend', () => rightPressed = false);
    document.getElementById('fireBtn').addEventListener('touchstart', e => { e.preventDefault(); shoot(); });

    document.getElementById('leftBtn').addEventListener('mousedown', () => leftPressed = true);
    document.getElementById('leftBtn').addEventListener('mouseup', () => leftPressed = false);
    document.getElementById('leftBtn').addEventListener('mouseleave', () => leftPressed = false);
    document.getElementById('rightBtn').addEventListener('mousedown', () => rightPressed = true);
    document.getElementById('rightBtn').addEventListener('mouseup', () => rightPressed = false);
    document.getElementById('rightBtn').addEventListener('mouseleave', () => rightPressed = false);
    document.getElementById('fireBtn').addEventListener('click', shoot);

    setInterval(() => {
      if (gameOver || !gameStarted) return;
      if (leftPressed && player.x > 0) player.x -= player.speed;
      if (rightPressed && player.x < W - player.w) player.x += player.speed;
    }, 16);

    document.getElementById('restart').addEventListener('click', () => {
      stopBGM();
      init();
      gameStarted = true;
      initAudio();
      startBGM();
      startOverlay.classList.remove('show');
    });
    document.getElementById('retryBtn').addEventListener('click', () => {
      stopBGM();
      init();
      gameStarted = true;
      initAudio();
      startBGM();
      startOverlay.classList.remove('show');
    });
    document.getElementById('startBtn').addEventListener('click', () => {
      gameStarted = true;
      initAudio();
      startBGM();
      startOverlay.classList.remove('show');
    });

    // ãƒ©ãƒ³ã‚­ãƒ³ã‚°ãƒœã‚¿ãƒ³
    document.getElementById('rankingBtn').addEventListener('click', () => {
      Ranking.showRankingModal('invader');
    });

    init();
    gameLoop();
  </script>
</body>
</html>
