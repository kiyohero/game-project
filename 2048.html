<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>2048</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; background: #f5f0fa; min-height: 100vh; display: flex; flex-direction: column; align-items: center; padding: 20px; user-select: none; -webkit-user-select: none; }
    .game-area { touch-action: none; }
    h1 { font-size: 3rem; color: #6b5b7a; margin-bottom: 10px; }
    .header { display: flex; align-items: center; gap: 10px; margin-bottom: 20px; width: 100%; max-width: 340px; justify-content: space-between; }
    .score-container { background: #9b8ab8; padding: 8px 15px; border-radius: 6px; text-align: center; min-width: 80px; position: relative; }
    .score-label { font-size: 0.65rem; color: #e8e0f0; text-transform: uppercase; font-weight: bold; }
    .score-value { font-size: 1.3rem; color: white; font-weight: bold; }
    .score-add { position: absolute; top: 50%; left: 50%; color: #9b8ab8; font-size: 1rem; font-weight: bold; pointer-events: none; animation: score-fly 0.8s ease-out forwards; }
    @keyframes score-fly { 0% { transform: translate(-50%, -50%); opacity: 1; } 100% { transform: translate(-50%, -150%); opacity: 0; } }
    .best-container { background: #7a6b8a; }
    .btn { background: #7a6b8a; color: white; border: none; padding: 10px 16px; border-radius: 6px; font-size: 0.9rem; font-weight: bold; cursor: pointer; transition: transform 0.1s; }
    .btn:hover { background: #6b5b7a; }
    .btn:active { transform: scale(0.95); }
    .grid-container { background: #9b8ab8; padding: 10px; border-radius: 8px; position: relative; width: 340px; height: 340px; box-shadow: 0 4px 20px rgba(107, 91, 122, 0.3); }
    .grid-bg { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; width: 100%; height: 100%; }
    .grid-cell { background: rgba(238, 228, 218, 0.4); border-radius: 4px; }
    .tile {
      position: absolute;
      width: 75px;
      height: 75px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.8rem;
      font-weight: bold;
      color: #776e65;
      transition: top 100ms ease-in-out, left 100ms ease-in-out;
      z-index: 10;
    }
    .tile.moving { z-index: 20; }
    .tile.new {
      animation: appear 200ms cubic-bezier(0.18, 0.89, 0.32, 1.28);
    }
    .tile.merged {
      animation: pop 200ms cubic-bezier(0.18, 0.89, 0.32, 1.28);
      z-index: 30;
    }
    @keyframes appear {
      0% { transform: scale(0); opacity: 0; }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); opacity: 1; }
    }
    @keyframes pop {
      0% { transform: scale(1); }
      40% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }
    .tile[data-value="2"] { background: #eee4da; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
    .tile[data-value="4"] { background: #ede0c8; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
    .tile[data-value="8"] { background: #f2b179; color: #f9f6f2; box-shadow: 0 2px 12px rgba(242, 177, 121, 0.4); }
    .tile[data-value="16"] { background: #f59563; color: #f9f6f2; box-shadow: 0 2px 12px rgba(245, 149, 99, 0.4); }
    .tile[data-value="32"] { background: #f67c5f; color: #f9f6f2; box-shadow: 0 2px 15px rgba(246, 124, 95, 0.5); }
    .tile[data-value="64"] { background: #f65e3b; color: #f9f6f2; box-shadow: 0 2px 15px rgba(246, 94, 59, 0.5); }
    .tile[data-value="128"] { background: #edcf72; color: #f9f6f2; font-size: 1.5rem; box-shadow: 0 0 20px 5px rgba(237, 207, 114, 0.4); }
    .tile[data-value="256"] { background: #edcc61; color: #f9f6f2; font-size: 1.5rem; box-shadow: 0 0 20px 5px rgba(237, 204, 97, 0.5); }
    .tile[data-value="512"] { background: #edc850; color: #f9f6f2; font-size: 1.5rem; box-shadow: 0 0 25px 8px rgba(237, 200, 80, 0.5); }
    .tile[data-value="1024"] { background: #edc53f; color: #f9f6f2; font-size: 1.3rem; box-shadow: 0 0 30px 10px rgba(237, 197, 63, 0.6); }
    .tile[data-value="2048"] { background: #edc22e; color: #f9f6f2; font-size: 1.3rem; box-shadow: 0 0 35px 12px rgba(237, 194, 46, 0.7); animation: winner-glow 1s ease-in-out infinite; }
    @keyframes winner-glow {
      0%, 100% { box-shadow: 0 0 35px 12px rgba(237, 194, 46, 0.7); }
      50% { box-shadow: 0 0 45px 18px rgba(237, 194, 46, 0.9); }
    }
    .overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(250, 245, 255, 0.9); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; opacity: 0; pointer-events: none; transition: opacity 0.4s ease; }
    .overlay.show { opacity: 1; pointer-events: auto; }
    .overlay h2 { font-size: 2.5rem; color: #6b5b7a; margin-bottom: 20px; animation: message-pop 0.5s cubic-bezier(0.18, 0.89, 0.32, 1.28); }
    @keyframes message-pop { 0% { transform: scale(0.5); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
    .overlay .final-score { font-size: 1.2rem; color: #6b5b7a; margin-bottom: 20px; }
    .instructions { color: #9b8ab8; margin-top: 15px; font-size: 0.85rem; }
    .how-to-play { background: #e8e0f0; border-radius: 8px; margin-bottom: 20px; max-width: 340px; }
    .how-to-play summary { color: #6b5b7a; font-size: 1rem; font-weight: bold; padding: 12px 15px; cursor: pointer; list-style: none; display: flex; justify-content: space-between; align-items: center; }
    .how-to-play summary::-webkit-details-marker { display: none; }
    .how-to-play summary::after { content: '+'; font-size: 1.3rem; }
    .how-to-play[open] summary::after { content: '-'; }
    .how-to-play ul { color: #6b5b7a; font-size: 0.85rem; line-height: 1.8; padding: 0 15px 15px 35px; }
    .how-to-play li { margin-bottom: 5px; }
  </style>
</head>
<body>
  <h1>2048</h1>
  <details class="how-to-play">
    <summary>あそびかた</summary>
    <ul>
      <li>ゆびでスワイプ、またはキーボードの矢印キー（↑↓←→）でブロックをうごかすよ</li>
      <li>おなじ数字のブロックがぶつかると、くっついて2倍の数字になるよ</li>
      <li>2→4→8→16...とどんどん大きくして、「2048」を目指そう！</li>
      <li>うごかせなくなったらゲームオーバー。なんどでもチャレンジしてね！</li>
    </ul>
  </details>
  <div class="game-area">
    <div class="header">
      <div class="score-container">
        <div class="score-label">スコア</div>
        <div class="score-value" id="score">0</div>
      </div>
      <div class="score-container best-container">
        <div class="score-label">ベスト</div>
        <div class="score-value" id="best">0</div>
      </div>
      <button class="btn" id="restart">リトライ</button>
    </div>
    <div class="grid-container" id="grid">
      <div class="grid-bg">
        <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
        <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
        <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
        <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
      </div>
    </div>
    <p class="instructions">スワイプまたは矢印キーで操作</p>
  </div>
  <div class="overlay" id="overlay">
    <h2 id="message">ゲームオーバー</h2>
    <p class="final-score">スコア: <span id="finalScore">0</span></p>
    <button class="btn" id="retryBtn">もう一度</button>
  </div>
  <script>
    const gridEl = document.getElementById('grid');
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const messageEl = document.getElementById('message');
    const finalScoreEl = document.getElementById('finalScore');

    const CELL_SIZE = 75;
    const GAP = 10;
    const PADDING = 10;
    const MOVE_DURATION = 100;

    let grid = [];
    let tiles = [];
    let score = 0;
    let best = parseInt(localStorage.getItem('2048-best') || '0');
    let isAnimating = false;

    bestEl.textContent = best;

    function getPos(row, col) {
      return {
        top: PADDING + row * (CELL_SIZE + GAP),
        left: PADDING + col * (CELL_SIZE + GAP)
      };
    }

    function createTile(row, col, value, isNew = true) {
      const tile = document.createElement('div');
      tile.className = 'tile';
      tile.dataset.value = value;
      tile.textContent = value;
      const pos = getPos(row, col);
      tile.style.top = pos.top + 'px';
      tile.style.left = pos.left + 'px';

      if (isNew) {
        tile.style.transform = 'scale(0)';
        tile.style.opacity = '0';
      }

      gridEl.appendChild(tile);
      return { el: tile, row, col, value, merged: false };
    }

    function showNewTile(tile) {
      requestAnimationFrame(() => {
        tile.el.classList.add('new');
        tile.el.style.transform = '';
        tile.el.style.opacity = '';
      });
    }

    function showScoreAdd(points) {
      const add = document.createElement('div');
      add.className = 'score-add';
      add.textContent = '+' + points;
      scoreEl.parentElement.appendChild(add);
      setTimeout(() => add.remove(), 800);
    }

    function init() {
      grid = Array(4).fill(null).map(() => Array(4).fill(null));
      tiles.forEach(t => t.el.remove());
      tiles = [];
      score = 0;
      scoreEl.textContent = '0';
      overlay.classList.remove('show');
      isAnimating = false;

      addRandomTile(false);
      addRandomTile(false);

      setTimeout(() => {
        tiles.forEach(t => showNewTile(t));
      }, 50);
    }

    function addRandomTile(animate = true) {
      const empty = [];
      for (let r = 0; r < 4; r++) {
        for (let c = 0; c < 4; c++) {
          if (!grid[r][c]) empty.push({ r, c });
        }
      }
      if (empty.length === 0) return null;

      const { r, c } = empty[Math.floor(Math.random() * empty.length)];
      const value = Math.random() < 0.9 ? 2 : 4;
      const tile = createTile(r, c, value, animate);
      grid[r][c] = tile;
      tiles.push(tile);

      if (animate) {
        setTimeout(() => showNewTile(tile), 50);
      }

      return tile;
    }

    function moveTile(tile, newRow, newCol) {
      tile.el.classList.add('moving');
      const pos = getPos(newRow, newCol);
      tile.el.style.top = pos.top + 'px';
      tile.el.style.left = pos.left + 'px';
      tile.row = newRow;
      tile.col = newCol;

      setTimeout(() => tile.el.classList.remove('moving'), MOVE_DURATION);
    }

    function slideRow(rowArr, reverse) {
      let arr = reverse ? [...rowArr].reverse() : [...rowArr];
      let result = arr.filter(t => t !== null);
      let mergedTiles = [];
      let scoreGained = 0;

      for (let i = 0; i < result.length - 1; i++) {
        if (result[i] && result[i + 1] && result[i].value === result[i + 1].value && !result[i].merged && !result[i + 1].merged) {
          const newValue = result[i].value * 2;
          result[i].value = newValue;
          result[i].merged = true;
          scoreGained += newValue;

          mergedTiles.push({ survivor: result[i], removed: result[i + 1] });
          result[i + 1] = null;
        }
      }

      result = result.filter(t => t !== null);
      while (result.length < 4) result.push(null);

      if (reverse) result.reverse();
      return { result, mergedTiles, scoreGained };
    }

    function move(direction) {
      if (isAnimating) return;

      const oldState = JSON.stringify(grid.map(row => row.map(t => t ? t.value : 0)));
      let allMerged = [];
      let totalScoreGained = 0;

      // 全タイルのmergedフラグをリセット
      tiles.forEach(t => t.merged = false);

      if (direction === 'left' || direction === 'right') {
        for (let r = 0; r < 4; r++) {
          const { result, mergedTiles, scoreGained } = slideRow(grid[r], direction === 'right');
          allMerged.push(...mergedTiles);
          totalScoreGained += scoreGained;
          grid[r] = result;
          result.forEach((tile, c) => {
            if (tile) moveTile(tile, r, c);
          });
        }
      } else {
        for (let c = 0; c < 4; c++) {
          const col = [grid[0][c], grid[1][c], grid[2][c], grid[3][c]];
          const { result, mergedTiles, scoreGained } = slideRow(col, direction === 'down');
          allMerged.push(...mergedTiles);
          totalScoreGained += scoreGained;
          result.forEach((tile, r) => {
            grid[r][c] = tile;
            if (tile) moveTile(tile, r, c);
          });
        }
      }

      const newState = JSON.stringify(grid.map(row => row.map(t => t ? t.value : 0)));

      if (oldState !== newState) {
        isAnimating = true;

        // スコア更新
        if (totalScoreGained > 0) {
          score += totalScoreGained;
          scoreEl.textContent = score;
          showScoreAdd(totalScoreGained);

          if (score > best) {
            best = score;
            bestEl.textContent = best;
            localStorage.setItem('2048-best', best.toString());
          }
        }

        // マージアニメーション後の処理
        setTimeout(() => {
          allMerged.forEach(({ survivor, removed }) => {
            // 消えるタイルを削除
            removed.el.remove();
            tiles = tiles.filter(t => t !== removed);

            // 生き残ったタイルを更新してポップ
            survivor.el.dataset.value = survivor.value;
            survivor.el.textContent = survivor.value;
            survivor.el.classList.add('merged');
            setTimeout(() => survivor.el.classList.remove('merged'), 200);
          });

          // 新タイル追加
          setTimeout(() => {
            addRandomTile(true);
            isAnimating = false;

            // 勝利・敗北チェック
            for (let r = 0; r < 4; r++) {
              for (let c = 0; c < 4; c++) {
                if (grid[r][c] && grid[r][c].value === 2048) {
                  setTimeout(() => showOverlay('2048達成！'), 300);
                  return;
                }
              }
            }
            if (isGameOver()) {
              setTimeout(() => showOverlay('ゲームオーバー'), 300);
            }
          }, 50);
        }, MOVE_DURATION);
      }
    }

    function isGameOver() {
      for (let r = 0; r < 4; r++) {
        for (let c = 0; c < 4; c++) {
          if (!grid[r][c]) return false;
          if (c < 3 && grid[r][c].value === grid[r][c + 1]?.value) return false;
          if (r < 3 && grid[r][c].value === grid[r + 1][c]?.value) return false;
        }
      }
      return true;
    }

    function showOverlay(msg) {
      messageEl.textContent = msg;
      finalScoreEl.textContent = score;
      overlay.classList.add('show');
    }

    // キーボード操作
    document.addEventListener('keydown', e => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        e.preventDefault();
        move(e.key.replace('Arrow', '').toLowerCase());
      }
    });

    // タッチ操作
    let touchStartX = 0, touchStartY = 0;
    document.addEventListener('touchstart', e => {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    }, { passive: true });

    document.addEventListener('touchend', e => {
      if (!touchStartX || !touchStartY) return;
      const dx = e.changedTouches[0].clientX - touchStartX;
      const dy = e.changedTouches[0].clientY - touchStartY;
      if (Math.abs(dx) > Math.abs(dy)) {
        if (Math.abs(dx) > 30) move(dx > 0 ? 'right' : 'left');
      } else if (Math.abs(dy) > 30) {
        move(dy > 0 ? 'down' : 'up');
      }
      touchStartX = 0;
      touchStartY = 0;
    }, { passive: true });

    document.getElementById('restart').addEventListener('click', init);
    document.getElementById('retryBtn').addEventListener('click', init);

    init();
  </script>
</body>
</html>
