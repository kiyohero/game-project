<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>2048</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; background: #faf8ef; min-height: 100vh; display: flex; flex-direction: column; align-items: center; padding: 20px; user-select: none; -webkit-user-select: none; }
    .game-area { touch-action: none; }
    h1 { font-size: 3rem; color: #776e65; margin-bottom: 10px; }
    .header { display: flex; align-items: center; gap: 15px; margin-bottom: 20px; width: 100%; max-width: 340px; justify-content: space-between; }
    .score-container { background: #bbada0; padding: 10px 20px; border-radius: 6px; text-align: center; }
    .score-label { font-size: 0.7rem; color: #eee4da; text-transform: uppercase; font-weight: bold; }
    .score-value { font-size: 1.5rem; color: white; font-weight: bold; }
    .btn { background: #8f7a66; color: white; border: none; padding: 12px 20px; border-radius: 6px; font-size: 1rem; font-weight: bold; cursor: pointer; }
    .btn:active { transform: scale(0.95); }
    .grid-container { background: #bbada0; padding: 10px; border-radius: 6px; position: relative; width: 340px; height: 340px; }
    .grid-bg { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; width: 100%; height: 100%; }
    .grid-cell { background: rgba(238,228,218,0.35); border-radius: 4px; }
    .tile { position: absolute; width: 75px; height: 75px; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 1.8rem; font-weight: bold; color: #776e65; transition: top 0.12s ease-out, left 0.12s ease-out; }
    .tile.new { animation: appear 0.15s ease-out; }
    .tile.merged { animation: pop 0.15s ease-out; }
    @keyframes appear { 0% { transform: scale(0); } 100% { transform: scale(1); } }
    @keyframes pop { 0% { transform: scale(1); } 50% { transform: scale(1.15); } 100% { transform: scale(1); } }
    .tile[data-value="2"] { background: #eee4da; }
    .tile[data-value="4"] { background: #ede0c8; }
    .tile[data-value="8"] { background: #f2b179; color: #f9f6f2; }
    .tile[data-value="16"] { background: #f59563; color: #f9f6f2; }
    .tile[data-value="32"] { background: #f67c5f; color: #f9f6f2; }
    .tile[data-value="64"] { background: #f65e3b; color: #f9f6f2; }
    .tile[data-value="128"] { background: #edcf72; color: #f9f6f2; font-size: 1.5rem; }
    .tile[data-value="256"] { background: #edcc61; color: #f9f6f2; font-size: 1.5rem; }
    .tile[data-value="512"] { background: #edc850; color: #f9f6f2; font-size: 1.5rem; }
    .tile[data-value="1024"] { background: #edc53f; color: #f9f6f2; font-size: 1.3rem; }
    .tile[data-value="2048"] { background: #edc22e; color: #f9f6f2; font-size: 1.3rem; }
    .overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(255,255,255,0.8); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; opacity: 0; pointer-events: none; transition: opacity 0.3s; }
    .overlay.show { opacity: 1; pointer-events: auto; }
    .overlay h2 { font-size: 2.5rem; color: #776e65; margin-bottom: 20px; }
    .overlay .final-score { font-size: 1.2rem; color: #776e65; margin-bottom: 20px; }
    .instructions { color: #776e65; margin-top: 15px; font-size: 0.9rem; }
    .how-to-play { background: #eee4da; border-radius: 8px; margin-bottom: 20px; max-width: 340px; }
    .how-to-play summary { color: #776e65; font-size: 1.1rem; font-weight: bold; padding: 12px 15px; cursor: pointer; list-style: none; display: flex; justify-content: space-between; align-items: center; }
    .how-to-play summary::-webkit-details-marker { display: none; }
    .how-to-play summary::after { content: '+'; font-size: 1.3rem; }
    .how-to-play[open] summary::after { content: '-'; }
    .how-to-play ul { color: #776e65; font-size: 0.9rem; line-height: 1.8; padding: 0 15px 15px 35px; }
    .how-to-play li { margin-bottom: 5px; }
  </style>
</head>
<body>
  <h1>2048</h1>
  <details class="how-to-play">
    <summary>あそびかた</summary>
    <ul>
      <li>ゆびでスワイプ、またはキーボードの矢印キー（↑↓←→）でブロックをうごかすよ</li>
      <li>おなじ数字のブロックがぶつかると、くっついて2倍の数字になるよ</li>
      <li>2→4→8→16...とどんどん大きくして、「2048」を目指そう！</li>
      <li>うごかせなくなったらゲームオーバー。なんどでもチャレンジしてね！</li>
    </ul>
  </details>
  <div class="game-area">
    <div class="header">
      <div class="score-container">
        <div class="score-label">スコア</div>
        <div class="score-value" id="score">0</div>
      </div>
      <button class="btn" id="restart">リトライ</button>
    </div>
    <div class="grid-container" id="grid">
      <div class="grid-bg">
        <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
        <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
        <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
        <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
      </div>
    </div>
    <p class="instructions">スワイプまたは矢印キーで操作</p>
  </div>
  <div class="overlay" id="overlay">
    <h2 id="message">ゲームオーバー</h2>
    <p class="final-score">スコア: <span id="finalScore">0</span></p>
    <button class="btn" id="retryBtn">もう一度</button>
  </div>
  <script>
    const gridEl = document.getElementById('grid');
    const scoreEl = document.getElementById('score');
    const overlay = document.getElementById('overlay');
    const messageEl = document.getElementById('message');
    const finalScoreEl = document.getElementById('finalScore');

    const CELL_SIZE = 75;
    const GAP = 10;
    const PADDING = 10;

    let grid = [];
    let tiles = [];
    let score = 0;
    let isAnimating = false;

    function getPos(row, col) {
      return {
        top: PADDING + row * (CELL_SIZE + GAP),
        left: PADDING + col * (CELL_SIZE + GAP)
      };
    }

    function createTile(row, col, value, isNew = true) {
      const tile = document.createElement('div');
      tile.className = 'tile' + (isNew ? ' new' : '');
      tile.dataset.value = value;
      tile.textContent = value;
      const pos = getPos(row, col);
      tile.style.top = pos.top + 'px';
      tile.style.left = pos.left + 'px';
      gridEl.appendChild(tile);
      return { el: tile, row, col, value };
    }

    function init() {
      grid = Array(4).fill(null).map(() => Array(4).fill(null));
      tiles.forEach(t => t.el.remove());
      tiles = [];
      score = 0;
      scoreEl.textContent = '0';
      overlay.classList.remove('show');
      isAnimating = false;
      addRandomTile();
      addRandomTile();
    }

    function addRandomTile() {
      const empty = [];
      for (let r = 0; r < 4; r++) {
        for (let c = 0; c < 4; c++) {
          if (!grid[r][c]) empty.push({ r, c });
        }
      }
      if (empty.length === 0) return;
      const { r, c } = empty[Math.floor(Math.random() * empty.length)];
      const value = Math.random() < 0.9 ? 2 : 4;
      const tile = createTile(r, c, value, true);
      grid[r][c] = tile;
      tiles.push(tile);
    }

    function moveTile(tile, newRow, newCol) {
      const pos = getPos(newRow, newCol);
      tile.el.style.top = pos.top + 'px';
      tile.el.style.left = pos.left + 'px';
      tile.row = newRow;
      tile.col = newCol;
    }

    function slideRow(row, reverse) {
      let arr = reverse ? [...row].reverse() : [...row];
      let result = arr.filter(t => t !== null);
      let merged = [];

      for (let i = 0; i < result.length - 1; i++) {
        if (result[i] && result[i + 1] && result[i].value === result[i + 1].value) {
          result[i].value *= 2;
          result[i].el.dataset.value = result[i].value;
          result[i].el.textContent = result[i].value;
          result[i].el.classList.add('merged');
          setTimeout(() => result[i].el.classList.remove('merged'), 150);
          score += result[i].value;

          // 消えるタイルを記録
          merged.push(result[i + 1]);
          result[i + 1] = null;
        }
      }

      result = result.filter(t => t !== null);
      while (result.length < 4) result.push(null);

      if (reverse) result.reverse();
      return { result, merged };
    }

    function move(direction) {
      if (isAnimating) return;

      const oldState = JSON.stringify(grid.map(row => row.map(t => t ? t.value : 0)));
      let allMerged = [];

      if (direction === 'left' || direction === 'right') {
        for (let r = 0; r < 4; r++) {
          const { result, merged } = slideRow(grid[r], direction === 'right');
          allMerged.push(...merged);
          grid[r] = result;
          result.forEach((tile, c) => {
            if (tile) moveTile(tile, r, c);
          });
        }
      } else {
        for (let c = 0; c < 4; c++) {
          const col = [grid[0][c], grid[1][c], grid[2][c], grid[3][c]];
          const { result, merged } = slideRow(col, direction === 'down');
          allMerged.push(...merged);
          result.forEach((tile, r) => {
            grid[r][c] = tile;
            if (tile) moveTile(tile, r, c);
          });
        }
      }

      const newState = JSON.stringify(grid.map(row => row.map(t => t ? t.value : 0)));

      if (oldState !== newState) {
        isAnimating = true;
        scoreEl.textContent = score;

        // マージされたタイルを削除
        setTimeout(() => {
          allMerged.forEach(t => {
            t.el.remove();
            tiles = tiles.filter(tile => tile !== t);
          });

          addRandomTile();
          isAnimating = false;

          // 勝利・敗北チェック
          for (let r = 0; r < 4; r++) {
            for (let c = 0; c < 4; c++) {
              if (grid[r][c] && grid[r][c].value === 2048) {
                setTimeout(() => showOverlay('2048達成！'), 100);
                return;
              }
            }
          }
          if (isGameOver()) {
            setTimeout(() => showOverlay('ゲームオーバー'), 100);
          }
        }, 120);
      }
    }

    function isGameOver() {
      for (let r = 0; r < 4; r++) {
        for (let c = 0; c < 4; c++) {
          if (!grid[r][c]) return false;
          if (c < 3 && grid[r][c].value === grid[r][c + 1]?.value) return false;
          if (r < 3 && grid[r][c].value === grid[r + 1][c]?.value) return false;
        }
      }
      return true;
    }

    function showOverlay(msg) {
      messageEl.textContent = msg;
      finalScoreEl.textContent = score;
      overlay.classList.add('show');
    }

    // キーボード操作
    document.addEventListener('keydown', e => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        e.preventDefault();
        move(e.key.replace('Arrow', '').toLowerCase());
      }
    });

    // タッチ操作
    let touchStartX = 0, touchStartY = 0;
    document.addEventListener('touchstart', e => {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    }, { passive: true });

    document.addEventListener('touchend', e => {
      if (!touchStartX || !touchStartY) return;
      const dx = e.changedTouches[0].clientX - touchStartX;
      const dy = e.changedTouches[0].clientY - touchStartY;
      if (Math.abs(dx) > Math.abs(dy)) {
        if (Math.abs(dx) > 30) move(dx > 0 ? 'right' : 'left');
      } else if (Math.abs(dy) > 30) {
        move(dy > 0 ? 'down' : 'up');
      }
      touchStartX = 0;
      touchStartY = 0;
    }, { passive: true });

    document.getElementById('restart').addEventListener('click', init);
    document.getElementById('retryBtn').addEventListener('click', init);

    init();
  </script>
</body>
</html>
