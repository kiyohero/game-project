<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>オセロ（リバーシ）</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; background: #f5f0fa; min-height: 100vh; display: flex; flex-direction: column; align-items: center; padding: 20px; user-select: none; -webkit-user-select: none; }
    h1 { font-size: 2.5rem; color: #6b5b7a; margin-bottom: 10px; }
    .how-to-play { background: #e8e0f0; border-radius: 8px; margin-bottom: 20px; max-width: 340px; width: 100%; }
    .how-to-play summary { color: #6b5b7a; font-size: 1.1rem; font-weight: bold; padding: 12px 15px; cursor: pointer; list-style: none; display: flex; justify-content: space-between; align-items: center; }
    .how-to-play summary::-webkit-details-marker { display: none; }
    .how-to-play summary::after { content: '+'; font-size: 1.3rem; }
    .how-to-play[open] summary::after { content: '-'; }
    .how-to-play ul { color: #6b5b7a; font-size: 0.9rem; line-height: 1.8; padding: 0 15px 15px 35px; }
    .how-to-play li { margin-bottom: 5px; }
    .header { display: flex; align-items: center; gap: 15px; margin-bottom: 15px; width: 100%; max-width: 340px; justify-content: space-between; }
    .score-container { background: #9b8ab8; padding: 10px 15px; border-radius: 6px; text-align: center; display: flex; align-items: center; gap: 10px; }
    .score-item { display: flex; align-items: center; gap: 6px; }
    .stone-icon { width: 20px; height: 20px; border-radius: 50%; }
    .stone-icon.black { background: #333; }
    .stone-icon.white { background: #fff; border: 1px solid #ccc; }
    .score-value { font-size: 1.3rem; color: white; font-weight: bold; }
    .btn { background: #7a6b8a; color: white; border: none; padding: 12px 20px; border-radius: 6px; font-size: 1rem; font-weight: bold; cursor: pointer; }
    .btn:active { transform: scale(0.95); }
    .mode-select { display: flex; gap: 10px; margin-bottom: 15px; }
    .mode-btn { background: #c5b8d8; color: #6b5b7a; border: none; padding: 8px 16px; border-radius: 6px; font-size: 0.9rem; font-weight: bold; cursor: pointer; }
    .mode-btn.active { background: #7a6b8a; color: white; }
    .mode-btn:active { transform: scale(0.95); }
    .turn-indicator { background: #e8e0f0; padding: 8px 16px; border-radius: 6px; margin-bottom: 15px; color: #6b5b7a; font-weight: bold; }
    .board { background: #2d8a4e; padding: 4px; border-radius: 6px; display: grid; grid-template-columns: repeat(8, 1fr); gap: 2px; width: 340px; height: 340px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
    .cell { background: #3a9d5d; border-radius: 2px; display: flex; align-items: center; justify-content: center; cursor: pointer; position: relative; }
    .cell:hover { background: #4aad6d; }
    .cell.valid::after { content: ''; position: absolute; width: 12px; height: 12px; border-radius: 50%; background: rgba(255,255,255,0.3); }
    .stone { width: 85%; height: 85%; border-radius: 50%; transition: transform 0.3s ease; }
    .stone.black { background: radial-gradient(circle at 30% 30%, #555, #222); box-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
    .stone.white { background: radial-gradient(circle at 30% 30%, #fff, #ddd); box-shadow: 2px 2px 4px rgba(0,0,0,0.2); }
    .stone.flip { animation: flip 0.4s ease; }
    @keyframes flip { 0% { transform: rotateY(0deg); } 50% { transform: rotateY(90deg); } 100% { transform: rotateY(0deg); } }
    .overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(255,255,255,0.9); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; opacity: 0; pointer-events: none; transition: opacity 0.3s; }
    .overlay.show { opacity: 1; pointer-events: auto; }
    .overlay h2 { font-size: 2.5rem; color: #6b5b7a; margin-bottom: 15px; }
    .overlay .result { font-size: 1.2rem; color: #6b5b7a; margin-bottom: 20px; }
    .instructions { color: #6b5b7a; margin-top: 15px; font-size: 0.9rem; }
  </style>
</head>
<body>
  <h1>オセロ</h1>
  <details class="how-to-play">
    <summary>あそびかた</summary>
    <ul>
      <li>黒と白の石をつかって、たくさん自分の色にしよう！</li>
      <li>相手の石をはさむと、自分の色にひっくり返せるよ</li>
      <li>おける場所は光っているマスだけ。光るマスがないときはパス！</li>
      <li>最後にたくさん石があるほうが勝ちだよ</li>
    </ul>
  </details>
  <div class="mode-select">
    <button class="mode-btn active" id="vsPlayer">2人で対戦</button>
    <button class="mode-btn" id="vsCPU">CPUと対戦</button>
  </div>
  <div class="header">
    <div class="score-container">
      <div class="score-item">
        <div class="stone-icon black"></div>
        <span class="score-value" id="blackScore">2</span>
      </div>
      <div class="score-item">
        <div class="stone-icon white"></div>
        <span class="score-value" id="whiteScore">2</span>
      </div>
    </div>
    <button class="btn" id="restart">リスタート</button>
  </div>
  <div class="turn-indicator" id="turnIndicator">黒のばん</div>
  <div class="board" id="board"></div>
  <p class="instructions">光っているマスをタップ！</p>
  <div class="overlay" id="overlay">
    <h2 id="winner">黒の勝ち！</h2>
    <p class="result" id="result">黒: 32 - 白: 32</p>
    <button class="btn" id="retryBtn">もう一度</button>
  </div>

  <script>
    const boardEl = document.getElementById('board');
    const blackScoreEl = document.getElementById('blackScore');
    const whiteScoreEl = document.getElementById('whiteScore');
    const turnIndicatorEl = document.getElementById('turnIndicator');
    const overlay = document.getElementById('overlay');
    const winnerEl = document.getElementById('winner');
    const resultEl = document.getElementById('result');
    const vsPlayerBtn = document.getElementById('vsPlayer');
    const vsCPUBtn = document.getElementById('vsCPU');

    const EMPTY = 0, BLACK = 1, WHITE = 2;
    const DIRECTIONS = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];

    let board = [];
    let currentPlayer = BLACK;
    let vsCPU = false;
    let isAnimating = false;

    function init() {
      board = Array(8).fill(null).map(() => Array(8).fill(EMPTY));
      board[3][3] = WHITE; board[3][4] = BLACK;
      board[4][3] = BLACK; board[4][4] = WHITE;
      currentPlayer = BLACK;
      isAnimating = false;
      overlay.classList.remove('show');
      renderBoard();
      updateScore();
      updateTurnIndicator();
    }

    function renderBoard() {
      boardEl.innerHTML = '';
      const validMoves = getValidMoves(currentPlayer);

      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const cell = document.createElement('div');
          cell.className = 'cell';

          if (validMoves.some(m => m.r === r && m.c === c)) {
            cell.classList.add('valid');
          }

          if (board[r][c] !== EMPTY) {
            const stone = document.createElement('div');
            stone.className = 'stone ' + (board[r][c] === BLACK ? 'black' : 'white');
            cell.appendChild(stone);
          }

          cell.addEventListener('click', () => handleClick(r, c));
          boardEl.appendChild(cell);
        }
      }
    }

    function getValidMoves(player) {
      const moves = [];
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          if (board[r][c] === EMPTY && getFlips(r, c, player).length > 0) {
            moves.push({ r, c });
          }
        }
      }
      return moves;
    }

    function getFlips(r, c, player) {
      const opponent = player === BLACK ? WHITE : BLACK;
      const flips = [];

      for (const [dr, dc] of DIRECTIONS) {
        const lineFlips = [];
        let nr = r + dr, nc = c + dc;

        while (nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && board[nr][nc] === opponent) {
          lineFlips.push({ r: nr, c: nc });
          nr += dr;
          nc += dc;
        }

        if (lineFlips.length > 0 && nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && board[nr][nc] === player) {
          flips.push(...lineFlips);
        }
      }

      return flips;
    }

    function handleClick(r, c) {
      if (isAnimating) return;
      if (vsCPU && currentPlayer === WHITE) return;

      const validMoves = getValidMoves(currentPlayer);
      if (!validMoves.some(m => m.r === r && m.c === c)) return;

      makeMove(r, c);
    }

    function makeMove(r, c) {
      const flips = getFlips(r, c, currentPlayer);
      if (flips.length === 0) return;

      isAnimating = true;
      board[r][c] = currentPlayer;

      // アニメーション付きでひっくり返す
      renderBoard();

      setTimeout(() => {
        flips.forEach(f => {
          board[f.r][f.c] = currentPlayer;
        });
        renderBoard();

        // ひっくり返すアニメーション
        flips.forEach(f => {
          const index = f.r * 8 + f.c;
          const stone = boardEl.children[index].querySelector('.stone');
          if (stone) stone.classList.add('flip');
        });

        setTimeout(() => {
          updateScore();
          switchTurn();
          isAnimating = false;
        }, 400);
      }, 100);
    }

    function switchTurn() {
      currentPlayer = currentPlayer === BLACK ? WHITE : BLACK;

      let validMoves = getValidMoves(currentPlayer);

      // パスの処理
      if (validMoves.length === 0) {
        currentPlayer = currentPlayer === BLACK ? WHITE : BLACK;
        validMoves = getValidMoves(currentPlayer);

        if (validMoves.length === 0) {
          // ゲーム終了
          endGame();
          return;
        }
      }

      updateTurnIndicator();
      renderBoard();

      // CPUの手番
      if (vsCPU && currentPlayer === WHITE) {
        setTimeout(cpuMove, 500);
      }
    }

    function cpuMove() {
      const validMoves = getValidMoves(WHITE);
      if (validMoves.length === 0) return;

      // 簡単なAI: 角を最優先、次に辺、それ以外はひっくり返せる数が多い手
      const corners = [[0,0],[0,7],[7,0],[7,7]];
      const edges = [];
      for (let i = 0; i < 8; i++) {
        edges.push([0,i],[7,i],[i,0],[i,7]);
      }

      // 角があれば取る
      for (const [r,c] of corners) {
        if (validMoves.some(m => m.r === r && m.c === c)) {
          makeMove(r, c);
          return;
        }
      }

      // 辺があれば取る
      for (const [r,c] of edges) {
        if (validMoves.some(m => m.r === r && m.c === c)) {
          makeMove(r, c);
          return;
        }
      }

      // 最も多くひっくり返せる手を選ぶ
      let bestMove = validMoves[0];
      let maxFlips = 0;

      for (const move of validMoves) {
        const flips = getFlips(move.r, move.c, WHITE).length;
        if (flips > maxFlips) {
          maxFlips = flips;
          bestMove = move;
        }
      }

      makeMove(bestMove.r, bestMove.c);
    }

    function updateScore() {
      let black = 0, white = 0;
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          if (board[r][c] === BLACK) black++;
          else if (board[r][c] === WHITE) white++;
        }
      }
      blackScoreEl.textContent = black;
      whiteScoreEl.textContent = white;
    }

    function updateTurnIndicator() {
      if (vsCPU) {
        turnIndicatorEl.textContent = currentPlayer === BLACK ? 'あなたのばん（黒）' : 'CPUのばん（白）';
      } else {
        turnIndicatorEl.textContent = currentPlayer === BLACK ? '黒のばん' : '白のばん';
      }
    }

    function endGame() {
      let black = 0, white = 0;
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          if (board[r][c] === BLACK) black++;
          else if (board[r][c] === WHITE) white++;
        }
      }

      let winner;
      if (black > white) {
        winner = vsCPU ? 'あなたの勝ち！' : '黒の勝ち！';
      } else if (white > black) {
        winner = vsCPU ? 'CPUの勝ち！' : '白の勝ち！';
      } else {
        winner = '引き分け！';
      }

      winnerEl.textContent = winner;
      resultEl.textContent = `黒: ${black} - 白: ${white}`;
      overlay.classList.add('show');
    }

    // モード切り替え
    vsPlayerBtn.addEventListener('click', () => {
      vsCPU = false;
      vsPlayerBtn.classList.add('active');
      vsCPUBtn.classList.remove('active');
      init();
    });

    vsCPUBtn.addEventListener('click', () => {
      vsCPU = true;
      vsCPUBtn.classList.add('active');
      vsPlayerBtn.classList.remove('active');
      init();
    });

    document.getElementById('restart').addEventListener('click', init);
    document.getElementById('retryBtn').addEventListener('click', init);

    init();
  </script>
</body>
</html>
